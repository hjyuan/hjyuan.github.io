---
layout:     post
title:      FuzzGen论文阅读笔记
subtitle:   模糊测试
date:       2020-08-08
author:     Jie_Y
header-img: [img/post-bg-fuzzgen.png](https://i.loli.net/2020/08/10/Y4EOZsBKJ3Uk18e.png)
catalog: true
tags:
    - 模糊测试
    - 漏洞挖掘
    - 二进制
---

# FuzzGen论文简报

## 论文信息

**题目：**

FuzzGen: Automatic Fuzzer Generation(FuzzGen: 自动模糊器生成)

**作者：**

Kyriakos K. Ispoglou：博士，HexHive成员，Google任职

Mathias
Payer：助理教授，领导HexHive，EPFL(洛桑联邦理工学院)计算机与通信科学学院，研究方向是软件系统安全、二进制利用和模糊测试，<https://nebelwelt.net/>

**发表期刊（会议）**：

Usenix Security 2020

**发表时间：**

2020

**开源仓库：**

<https://github.com/HexHive/FuzzGen>

## 论文简报

当对函数库进行模糊测试时，由于库无法单独运行，需要应用程序进行调用，因此很难达到良好的代码覆盖率，需要特定的API调用序列来建立必要的状态。但是它们间依赖关系(如先后的调用顺序)一般只会在文档中写出，对于fuzzing来说这就需要人工分析来针对这些接口写一些针对性的fuzz模板。为了解决这个问题，论文提出了一种在给定环境中自动合成复杂库的模糊器的工具FuzzGen，利用整个系统推断库的接口，专门为库合成模糊器。基于libfuzzer，通过推断API间的依赖关系自动生成模糊测试stub。实验表明FuzzGen不需要人工干预，可以应用于各种库，利用LibFuzzer实现了更高的代码覆盖率，发现了17个先前未修补的漏洞。

### 1、Why

传统灰盒模糊测试使用代码覆盖率确定是否进一步评估输入，但是模糊器可能会受到Coverage
Wall的限制，这是由于模型限制、输入生成或其他约束所致。

![](https://i.loli.net/2020/08/10/2tmyzJYFCi3GWpq.png)

但是传统灰盒模糊测试假定目标程序具有明确的界面，由于库的API接口多样性，每个库通过一组导出的API调用提供不同的接口，因此现有的方法不能处理代码库。库函数之间没有依赖项信息，使用正确的参数以正确的顺序才能调用函数，但是以随机参数调用随机函数不能利用库的隐式依赖关系，无法进行有效的模糊测试。

![](https://i.loli.net/2020/08/10/5G2RBbXrxOsq6Ai.png)

而libFuzzer通过编写模糊器stub调用所需的库函数，利用随即输入模糊测试状态和控制流。它需要分析人员针对library的特定组件编写一个fuzzer
stub，在其中声明必要状态的构建和正确的API调用顺序。但是由于手工进行编写，无法扩展到许多不同的库。

### 2、What

FuzzGen利用库和执行库的代码(库的consumer)，推断库API，来合成抽象API依赖图，生成模糊器stub。FuzzGen生成的模糊器stub使用libFuzzer，并使用Address
Sanitizer进行编译。整体流程如下，FuzzGen从目标库开始，执行整个系统分析以发现该库的所有consumer。首先FuzzGen分析目标库并收集系统上所有代码，这些代码利用该库中的功能来推断基本API。其次，FuzzGen构建抽象API依赖图(A2DG)，捕获所有有效的API交互。最后基于A2DG合成模糊器stub。主要包括三个模块：库API推断、A2DG构建、stub合成。

![](https://i.loli.net/2020/08/10/TOCUISAhNlWKyi6.png)

#### 库API推断

利用consumer的源文件推断库的API，首先分析目标库所有已声明的函数，然后标识所有consumer的头文件中声明的所有函数，然后二者取交集作为潜在的API函数集合，利用Clang框架在库和consumer的汇编过程中提取此信息。

![](https://i.loli.net/2020/08/10/MvLO5PaYtky2jiZ.png)

因为有重名函数的存在，所以有可能存在过度逼近的问题，识别出的潜在API函数属于另一个库。FuzzGen使用一种渐进的库推断方法，迭代编译与目标库链接的测试程序来检查每一个潜在的API函数，链接失败表示该函数不属于目标库。

#### A2DG构建

抽象API依赖图(A2DG)用于构造模糊器stub，封装了两种类型的依赖关系：数据依赖和控制依赖。控制依赖关系指示如何调用各种API调用，数据依赖描述API调用中参数和返回值之间的潜在依赖关系。A2DG类似于库API序列的粗粒度控制流图CFG。

A2DG的每个节点都对应一个API函数的单次调用，每条边代表API调用之间的控制流，它对跨API调用的控制流进行编码，并描述具体的调用信息。建立A2DG分为两步，首先构造一组基本的A2DG，每个consumer中的stub函数都会生成一个A2DG，然后将所有consumer的A2DG合并为一个。

![](https://i.loli.net/2020/08/10/xsZmoeHXuTiKJSn.png)

1.  构建基本的A2DG。首先FuzzGen为API生成CFG，然后遍历其中的基本块，迭代的删除不包含API调用序列的基本块。如果一个基本块包含多个API调用指令，则拆分为多个A2DG节点，每个节点只包含一个调用。构建之后，每个节点代表一个API调用，此生成的是控制依赖关系。由于间接函数调用会在CFG生成期间导致过度逼近的问题，FuzzGen使用LLVM链接时间优化(LTO)来分析通道提取A2DG。生成的调用序列如上图b所示。

2.  合并A2DG图。将两个具有公共节点的A2DG图从根节点开始，选择第一个公共节点，将其删除后将所有子节点迁移到另一个A2DG中，合并公共节点。利用向后切片和定位调用API函数的方法合并没有公共节点的A2DG图。

另外构建有效的模糊器A2DG需要控制依赖和数据依赖关系，上述只是建立控制依赖关系，对于数据依赖，FuzzGen进行两种分析：参数value-set推断和参数依赖关系分析。

#### **参数value-set推断**

对于fuzzer来说，参数值集推断回答了两个问题，它需要知道一个函数内哪些参数可以fuzz，以及如何去fuzz这些参数。在函数内部参数值集推断中，FuzzGen为每一个参数分配一个类型，将参数分为两类：基本参数和复合参数。由于复合函数是基本参数的集合，不能直接进行模糊测试。因此在目标库中针对每个函数的每个参数执行数据流分析来计算函数参数的可能值和对应类型。如果参数被用于switch，那它就被分配一个predefined类型，如果对于参数第一次使用的场景是写操作，那么就给他分配一个output类型。对于函数外部参数值集推断，FuzzGen为所有的API调用执行后向切片，并为参数分配相同的属性进行类型推断。然后进行参数值集合并，将函数内部推断和外部推断的值集和属性采用基于试探法进行合并。

#### **依赖关系分析**

FuzzGen通过精确的过程内跟踪和粗粒度的过程间跟踪进行数据流分析，来跟踪参数在API间的调用序列。首先利用函数的前向和后向切片通过函数别名分析、跨API调用跟踪和返回值来识别参数和返回值间的数据依赖关系。然后执行另一次的数据流分析识别每对参数和返回值之间的依赖关系。

#### stub合成

因为生成的A2DG可能包含复杂的控制流和循环，在生成A2DG之后，遍历A2DG进行flatten。首先针对循环删除后向的边，对于处理后的API依赖图，进行宽松的拓扑排序，在每个步骤中删除相同顺序的API函数，并把相同顺序的调用设为一组，随机调用函数组。然后FuzzGen通过完整的A2DG为不同的API调用及其参数创建模糊器stub，每个A2DG都生成一个stub。单个stub利用模糊器的熵遍历A2DG，通过对A2DG的所有可能路径进行编码，如果A2DG间不存在公共节点则保留两个A2DG。

### 3、How

实验利用7个编解码库进行模糊测试，首先手动分析了每个库的API使用情况，并为libhevc、libavc、libmpeg2和libgsm编写了手工模糊器stub作为对照。作者发现工具分析过多的consumer程序并不会增加覆盖率，因此通过计算使用的API数量除以代码总行数评判其质量。对每个fuzzer运行5次，每次运行24小时进行评估。

![](https://i.loli.net/2020/08/10/fda4qXTrxBlGtAm.png)

#### 代码覆盖率

使用线性插值法在给定的时间间隔内估算每次模糊测试的覆盖范围，然后计算每个时间间隔的平均代码覆盖率。平均而言覆盖率能够达到54.48%，人工只能达到48%，提高了6.5%左右。

![](https://i.loli.net/2020/08/10/ME6URyX4vFgiPxY.png)

![](https://i.loli.net/2020/08/10/875Jb1PmgvFYze6.png)

![](https://i.loli.net/2020/08/10/u2FJYc5sgkh6beG.png)

#### 效率

对不同平台的库进行测试，对于发现，对Libaom库FuzzGen的效果较好。虽然人工进行模糊测试发现的bug数量更多，因为人工更有针对性。

![](https://i.loli.net/2020/08/10/uDs68N13JyAwCLo.png)

### 4、Summary

论文的缺点在于每次FuzzGen只关注于单一函数库，没有考虑库之间的交互。另外在静态分析中和A2DG的合并过程中可能会导致伪路径，从而导致误报。在进行参数值集合并时采用试探法进行，效率和性能会有一定的影响并且结果不会太好。

论文提出了一种针对函数库进行模糊测试的新方法，在这个过程中代替了人工分析生成libFuzzer的stub，是否可以利用机器学习的方法进行stub生成，得到更好的效果，值得我们后续考虑。
