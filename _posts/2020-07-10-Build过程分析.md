---
layout:     post
title:      Build过程分析
subtitle:   编译
date:       2020-07-10
author:     Jie_Y
header-img: img/post-bg-build.jpeg
catalog: true
tags:
    - 编译原理
    - 二进制
---

# Build过程分析

一般IDE都将编译和链接过程合并一起，这个过程一般称为构建(`build`)  
实际上Build过程可以分为四个步骤：预处理(`Prepressing`)、编译(`Compilation`)、汇编(`Assembly`)、链接(`Linking`)  

![](https://i.loli.net/2020/08/10/dL2VUQmI5CjEXtZ.png)

## 预编译

预编译过程主要处理那些源代码文件中的以`#`开始的预编译指令  
> 处理规则不详细讲述，可以自己查一下

```bash
gcc -E hello.c -o hello.i
```


经过预编译后的.i文件不包含任何宏定义，所有宏定义都已经展开

## 编译

编译就是把处理完的.i文件进行词法分析、语法分析、语义分析及代码优化生成相应的汇编文件  


```shell
gcc -S hello.i -o hello.s
```

编译过程一般分为六个过程：扫描(词法分析)、语法分析、语义分析、源代码优化、代码生成和目标代码优化

### 词法分析

源代码经过扫描器进行词法分析，类似于有限状态机(FSA)，将源代码的字符序列分割成一系列的记号

记号一般有：关键字、标识符、字面量(数字、字符串等)、特殊符号(加号、等号)

`lex`可以实现词法扫描，将输入的字符串分割成一个个记号

### 语法分析

语法分析树对记号进行语法分析，生成语法树(`Syntax Tree`)，采用上下文无关语法，生成的语法树就是以表达式为节点的树

`yacc`语法分析工具可以完成语法分析

### 语义分析

语义分析器完成语义分析，完成语义的表示，仍是语法树

编译器分析的是静态语义，在编译期可以确定的语义，通常包括声明和类型的匹配，类型的转换，比如浮点表达式赋值给整型表达式

动态语义是在运行期才能确定的语义，比如0除是运行期语义错误

### 中间语言生成

源代码优化器完成语法树转换成中间代码，是语法树的顺序表示，主要有三地址码和P-代码

中间代码使编译器分为前端和后端，前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码

### 目标代码生成与优化

属于后端过程，包括代码生成器和目标代码优化器

转换成目标代码时依赖于目标机器，不同机器有不同的字长、寄存器等

代码优化其需要选择合适的寻址方式、使用位移代替乘法运算、删除多余的指令等

> 但是目标代码中`index`和`array`的地址还没确定
>
> 因此定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终连接的时候才能确定

## 汇编

汇编器见汇编代码转换成机器可执行的指令

```bash
as hello.s -o hello.o
```



## 链接

一个程序被分割成多个模块，模块间的通信方式有模块间的函数调用和模块间的变量访问，两者可归结为模块间符号的引用，两个模块相互拼接，拼接的过程即为**链接**

链接主要包括地址和空间分配(`Address and Storage Allocation`)、符号决议(`Symbol Resolution`)、重定位(`Relocation`，重新计算各个目标的地址过程)

目标文件和库一起链接形成最终的可执行文件，库就是运行时库(`Runtime Library`)

